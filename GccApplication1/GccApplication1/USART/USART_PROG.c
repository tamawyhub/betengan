/*
 * USART_PROG.c
 *
 * Created: 4/23/2021 2:14:48 AM
 *  Author: ahmed
 */ 
#include "std-types.h"
#include "USART_INT.h"
#include "USART_CONFIG.h"
#include "BIT_MATH.h"
#include "USART_PRIV.h"
#include "DIO_INT.h"
#include "CLK_CONFIG.h"

void USART_voidConfig()
{
	static volatile u8 * const prrs[]={(volatile u8 *)0x64,(volatile u8 *)0x65};

	#if USART0_STATE==ENABLED

	#if USART0_RXEN==ENABLED
	BIT_SET(UCSR0B,4);
	#endif
	
	#if USART0_TXEN==ENABLED
	BIT_SET(UCSR0B,3);
	#endif
	
	#if USART0_NDATABITS==NDATABITS_5
	BIT_CLR(UCSR0B,2);
	BIT_CLR(UCSR0C,2);
	BIT_CLR(UCSR0C,1);
	#elif USART0_NDATABITS==NDATABITS_6
	BIT_CLR(UCSR0B,2);
	BIT_CLR(UCSR0C,2);
	BIT_SET(UCSR0C,1);
	#elif USART0_NDATABITS==NDATABITS_7
	BIT_CLR(UCSR0B,2);
	BIT_SET(UCSR0C,2);
	BIT_CLR(UCSR0C,1);
	#elif USART0_NDATABITS==NDATABITS_8
	BIT_CLR(UCSR0B,2);
	BIT_SET(UCSR0C,2);
	BIT_SET(UCSR0C,1);
	#elif USART0_NDATABITS==NDATABITS_9
	BIT_SET(UCSR0B,2);
	BIT_SET(UCSR0C,2);
	BIT_SET(UCSR0C,1);
	#endif
	
	#if USART0_MODE==MODE_ASYNC
	BIT_CLR(UCSR0C,7);
	BIT_CLR(UCSR0C,6);
	#elif USART0_MODE==MODE_SYNC_MASTER
	BIT_CLR(UCSR0C,7);
	BIT_SET(UCSR0C,6);
	IO_voidPinMode(PORTE,PIN2,OUTPUT);
	#elif USART0_MODE==MODE_SYNC_SLAVE
	BIT_CLR(UCSR0C,7);
	BIT_SET(UCSR0C,6);
	IO_voidPinMode(PORTE,PIN2,INPUT);
	#elif USART0_MODE==MODE_MSPI
	BIT_SET(UCSR0C,7);
	BIT_SET(UCSR0C,6);
	#endif
	
	#if USART0_PARITY==PARITY_NONE
	BIT_CLR(UCSR0C,5);
	BIT_CLR(UCSR0C,4);
	#elif USART0_PARITY==PARITY_EVEN
	BIT_SET(UCSR0C,5);
	BIT_CLR(UCSR0C,4);
	#elif USART0_PARITY==PARITY_ODD
	BIT_SET(UCSR0C,5);
	BIT_SET(UCSR0C,4);
	#endif

	#if USART0_STOP==STOP_1
	BIT_CLR(UCSR0C,3);
	#elif USART0_STOP==STOP_2
	BIT_SET(UCSR0C,3);
	#endif

	#if USART0_MODE==MODE_ASYNC
	BIT_SET(UCSR0A,1);
	UBRR0=FOSC/8.0/USART0_BAUD-.5;
	#elif USART0_MODE==MODE_SYNC_MASTER || USART0_MODE==MODE_SYNC_SLAVE
	UBRR0=FOSC/2.0/USART0_BAUD-.5;
	#endif
	
	#else
	BIT_SET(*prrs[0],1);
	#endif	
///////////////////////////////////////////////////////////////////////////
	#if USART1_STATE==ENABLED

	#if USART1_RXEN==ENABLED
	BIT_SET(UCSR1B,4);
	#endif
	
	#if USART1_TXEN==ENABLED
	BIT_SET(UCSR1B,3);
	#endif
	
	#if USART1_NDATABITS==NDATABITS_5
	BIT_CLR(UCSR1B,2);
	BIT_CLR(UCSR1C,2);
	BIT_CLR(UCSR1C,1);
	#elif USART1_NDATABITS==NDATABITS_6
	BIT_CLR(UCSR1B,2);
	BIT_CLR(UCSR1C,2);
	BIT_SET(UCSR1C,1);
	#elif USART1_NDATABITS==NDATABITS_7
	BIT_CLR(UCSR1B,2);
	BIT_SET(UCSR1C,2);
	BIT_CLR(UCSR1C,1);
	#elif USART1_NDATABITS==NDATABITS_8
	BIT_CLR(UCSR1B,2);
	BIT_SET(UCSR1C,2);
	BIT_SET(UCSR1C,1);
	#elif USART1_NDATABITS==NDATABITS_9
	BIT_SET(UCSR1B,2);
	BIT_SET(UCSR1C,2);
	BIT_SET(UCSR1C,1);
	#endif
	
	#if USART1_MODE==MODE_ASYNC
	BIT_CLR(UCSR1C,7);
	BIT_CLR(UCSR1C,6);
	#elif USART1_MODE==MODE_SYNC_MASTER
	BIT_CLR(UCSR1C,7);
	BIT_SET(UCSR1C,6);
	IO_voidPinMode(PORTD,PIN5,OUTPUT);
	#elif USART1_MODE==MODE_SYNC_SLAVE
	BIT_CLR(UCSR1C,7);
	BIT_SET(UCSR1C,6);
	IO_voidPinMode(PORTD,PIN5,INPUT);
	#elif USART1_MODE==MODE_MSPI
	BIT_SET(UCSR1C,7);
	BIT_SET(UCSR1C,6);
	#endif
	
	#if USART1_PARITY==PARITY_NONE
	BIT_CLR(UCSR1C,5);
	BIT_CLR(UCSR1C,4);
	#elif USART1_PARITY==PARITY_EVEN
	BIT_SET(UCSR1C,5);
	BIT_CLR(UCSR1C,4);
	#elif USART1_PARITY==PARITY_ODD
	BIT_SET(UCSR1C,5);
	BIT_SET(UCSR1C,4);
	#endif

	#if USART1_STOP==STOP_1
	BIT_CLR(UCSR1C,3);
	#elif USART1_STOP==STOP_2
	BIT_SET(UCSR1C,3);
	#endif

	#if USART1_MODE==MODE_ASYNC
	BIT_SET(UCSR1A,1);
	UBRR1=FOSC/8.0/USART1_BAUD-.5;
	#elif USART1_MODE==MODE_SYNC_MASTER || USART1_MODE==MODE_SYNC_SLAVE
	UBRR1=FOSC/2.0/USART1_BAUD-.5;
	#endif
	
	#else
	BIT_SET(*prrs[1],0);
	#endif
/////////////////////////////////////////////////////////////////////////////
	#if USART2_STATE==ENABLED

	#if USART2_RXEN==ENABLED
	BIT_SET(UCSR2B,4);
	#endif
	
	#if USART2_TXEN==ENABLED
	BIT_SET(UCSR2B,3);
	#endif
	
	#if USART2_NDATABITS==NDATABITS_5
	BIT_CLR(UCSR2B,2);
	BIT_CLR(UCSR2C,2);
	BIT_CLR(UCSR2C,1);
	#elif USART2_NDATABITS==NDATABITS_6
	BIT_CLR(UCSR2B,2);
	BIT_CLR(UCSR2C,2);
	BIT_SET(UCSR2C,1);
	#elif USART2_NDATABITS==NDATABITS_7
	BIT_CLR(UCSR2B,2);
	BIT_SET(UCSR2C,2);
	BIT_CLR(UCSR2C,1);
	#elif USART2_NDATABITS==NDATABITS_8
	BIT_CLR(UCSR2B,2);
	BIT_SET(UCSR2C,2);
	BIT_SET(UCSR2C,1);
	#elif USART2_NDATABITS==NDATABITS_9
	BIT_SET(UCSR2B,2);
	BIT_SET(UCSR2C,2);
	BIT_SET(UCSR2C,1);
	#endif
	
	#if USART2_MODE==MODE_ASYNC
	BIT_CLR(UCSR2C,7);
	BIT_CLR(UCSR2C,6);
	#elif USART2_MODE==MODE_SYNC_MASTER
	BIT_CLR(UCSR2C,7);
	BIT_SET(UCSR2C,6);
	IO_voidPinMode(PORTH,PIN2,OUTPUT);
	#elif USART2_MODE==MODE_SYNC_SLAVE
	BIT_CLR(UCSR2C,7);
	BIT_SET(UCSR2C,6);
	IO_voidPinMode(PORTH,PIN2,INPUT);
	#elif USART2_MODE==MODE_MSPI
	BIT_SET(UCSR2C,7);
	BIT_SET(UCSR2C,6);
	#endif
	
	#if USART2_PARITY==PARITY_NONE
	BIT_CLR(UCSR2C,5);
	BIT_CLR(UCSR2C,4);
	#elif USART2_PARITY==PARITY_EVEN
	BIT_SET(UCSR2C,5);
	BIT_CLR(UCSR2C,4);
	#elif USART2_PARITY==PARITY_ODD
	BIT_SET(UCSR2C,5);
	BIT_SET(UCSR2C,4);
	#endif

	#if USART2_STOP==STOP_1
	BIT_CLR(UCSR2C,3);
	#elif USART2_STOP==STOP_2
	BIT_SET(UCSR2C,3);
	#endif

	#if USART2_MODE==MODE_ASYNC
	BIT_SET(UCSR2A,1);
	UBRR2=FOSC/8.0/USART2_BAUD-.5;
	#elif USART2_MODE==MODE_SYNC_MASTER || USART2_MODE==MODE_SYNC_SLAVE
	UBRR2=FOSC/2.0/USART2_BAUD-.5;
	#endif
	
	#else
	BIT_SET(*prrs[1],1);
	#endif
//////////////////////////////////////////////////////////////////////////////////
	#if USART3_STATE==ENABLED

	#if USART3_RXEN==ENABLED
	BIT_SET(UCSR3B,4);
	#endif
	
	#if USART3_TXEN==ENABLED
	BIT_SET(UCSR3B,3);
	#endif
	
	#if USART3_NDATABITS==NDATABITS_5
	BIT_CLR(UCSR3B,2);
	BIT_CLR(UCSR3C,2);
	BIT_CLR(UCSR3C,1);
	#elif USART3_NDATABITS==NDATABITS_6
	BIT_CLR(UCSR3B,2);
	BIT_CLR(UCSR3C,2);
	BIT_SET(UCSR3C,1);
	#elif USART3_NDATABITS==NDATABITS_7
	BIT_CLR(UCSR3B,2);
	BIT_SET(UCSR3C,2);
	BIT_CLR(UCSR3C,1);
	#elif USART3_NDATABITS==NDATABITS_8
	BIT_CLR(UCSR3B,2);
	BIT_SET(UCSR3C,2);
	BIT_SET(UCSR3C,1);
	#elif USART3_NDATABITS==NDATABITS_9
	BIT_SET(UCSR3B,2);
	BIT_SET(UCSR3C,2);
	BIT_SET(UCSR3C,1);
	#endif
	
	#if USART3_MODE==MODE_ASYNC
	BIT_CLR(UCSR3C,7);
	BIT_CLR(UCSR3C,6);
	#elif USART3_MODE==MODE_SYNC_MASTER
	BIT_CLR(UCSR3C,7);
	BIT_SET(UCSR3C,6);
	IO_voidPinMode(PORTJ,PIN2,OUTPUT);
	#elif USART3_MODE==MODE_SYNC_SLAVE
	BIT_CLR(UCSR3C,7);
	BIT_SET(UCSR3C,6);
	IO_voidPinMode(PORTJ,PIN2,INPUT);
	#elif USART3_MODE==MODE_MSPI
	BIT_SET(UCSR3C,7);
	BIT_SET(UCSR3C,6);
	#endif
	
	#if USART3_PARITY==PARITY_NONE
	BIT_CLR(UCSR3C,5);
	BIT_CLR(UCSR3C,4);
	#elif USART3_PARITY==PARITY_EVEN
	BIT_SET(UCSR3C,5);
	BIT_CLR(UCSR3C,4);
	#elif USART3_PARITY==PARITY_ODD
	BIT_SET(UCSR3C,5);
	BIT_SET(UCSR3C,4);
	#endif

	#if USART3_STOP==STOP_1
	BIT_CLR(UCSR3C,3);
	#elif USART3_STOP==STOP_2
	BIT_SET(UCSR3C,3);
	#endif

	#if USART3_MODE==MODE_ASYNC
	BIT_SET(UCSR3A,1);
	UBRR3=FOSC/8.0/USART3_BAUD-.5;
	#elif USART3_MODE==MODE_SYNC_MASTER || USART3_MODE==MODE_SYNC_SLAVE
	UBRR3=FOSC/2.0/USART3_BAUD-.5;
	#endif
	
	#else
	BIT_SET(*prrs[1],2);
	#endif
}
void USART_voidTransfer(USARTType usart, u8 data)
{
	static volatile u8 * const udrs[]={&UDR0TXB,&UDR1TXB,&UDR2TXB,&UDR3TXB};
	static volatile u8 * const ucsras[]={&UCSR0A,&UCSR1A,&UCSR2A,&UCSR3A};
	while(!((*ucsras[usart]) & (1<<5)));
	*(udrs[usart])=data;
}
u8 USART_u8Receive(USARTType usart)
{
	static volatile u8 * const udrs[]={&UDR0TXB,&UDR1TXB,&UDR2TXB,&UDR3TXB};
	static volatile u8 * const ucsras[]={&UCSR0A,&UCSR1A,&UCSR2A,&UCSR3A};
	while(!((*ucsras[usart]) & (1<<7)));
	return *(udrs[usart]);
}
